* lots of stuff is missing
		where is element->parent?  multiple levels shouldn't be a problem, but I don't know where this is done 

		how is the looping actually done?
			this warrants a long explanation and possibly a rewrite



* this took me a long ASS time to figure out...
x		check lines 1273 - 1290 or so... 
x		actions that are not loops are stubs (as currently written)
		check parent's nullness(ct->parent + ct->psize), if not null, it is now the blob 
		check that indices are coming back the right way, and also check that depth is affected the right way
		test and see if double/triple deep table keys are working as they should...
		maybe 30 min for this

* walk through double triple looping
		you've got to loop other already looped values,

		a <<EOF
			<html>	
				<a href="/{{ href }}">{{ href_text }}</a>
			</html>	
		EOF
	
* the way it's written right now, marking does'nt handle everything
		a better mark for purposes of caching would:
			find each index where something occurred, (the exact index) and store it an array
			(obviously, this array would be crazy long, it would also have keep a reference to the type of element)
		this way, action doesn't quite matter so much, it's probably only needed at 
		sizeof Mark =
		sizeof int[2] = 16 
	
		


* convert docs to markdown

* put this in some kind of bug tracking system

* if this file is being tracked, stop it	

* check most of the items here because stuff has probably been done...

* sql bugs
	works much better...
	- maybe write macros / oneshots should be macros...
	x write comparison part
	- handle errors better (some things should return an error, make sure they are)  
		t->error == t->statusExpected
	x remove function pointer and replace with one static function that handles types
	x	static int sq_add( sqlite3_stmt *stmt, int i, const SQWrite *w ): returns sqlite3_bind_* result...
		add another for mysql/postgres/etc...


* network
	how do I integrate SSL / TLS?
	SSL / TLS context can be passed in via userdata, just gotta look at how it's done...


* socket
	SOCKET_SERVER, SOCKET_CLIENT can be used as shortcodes to socket init

	
* CLEAN UP!!!!
	- lots of old sql functions, no longer needed, will cut at least 500 lines from the code base

* compile time crash when objects are not there
	look at the Linux source code for this...

* errors don't write everywhere yet
		(etc)->error = ERROR_CODE

* rendering
	kind of broken, cuz I can't get into the hash tables...	

